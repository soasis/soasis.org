+++
title = "The Deepest Mirror - A Plan for Generic Compile-Time Introspection in Rust"
description = "A look at the inspection of types and values in Rust, without the usual run-time baggage."
author = "Shepherd, ThePhD"
date = "2023-04-18"
slug = "the-deepest-mirror-a-plan-for-generic-compile-time-introspection-in-Rust"
tags = ["Rust", "core", "const", "reflection", "uwuflection", "introspection", "introwospection"]
categories = ["Rust"]
[[images]]
  src = "/img/2023/04/pexels-bogdan-dirica-mirror-ball.jpg"
  alt = "A reflective glass ball sits on a root of a tree, photographed upside-down to allow for the reflection inside of the glass ball to appear right-side up. The reflection shows the sky and the trees around in the forested area."
+++

With a powerful trait system, compile-time constants, and `where`-and-`:`-style bounding for types and constants, Rust's take on generic functions has been a refreshing departure from the anything-goes, Wild Wild West, errors-only-when-called template system of C++. Furthermore, its macro system has been a much needed replacement of C's underpowered macro system, allowing users to actually generate code in a consistent and dependable manner at compile-time, with the ever-powerful Procedural Macros ("proc macros") taking care of some of the heaviest language extension tasks. But...<!--more-->

It has become increasingly clear that, much like C, Rust has come to rely perhaps a bit too heavily on (proc) macros and code generation techniques to get around their inability to observe the properties of their own programming constructs. To this end, we have begun working on the specification, formalization, and potential integration of an set of core language primitives we are bikeshed-naming `introwospection`, which we hope to make available under the `core::introwospection` and `std::introwospection` modules in Rust.




# ... `introwospection` ...?

The name is a placeholder. Originally, we wanted to simply call it "reflect" and "reflection", but both terms already have some reserved meanings in Rust, including in the compiler as a reserved symbol. It was then changed to "uwuflection", but — as you will see below — we are not doing code generation (in the macro sense) with this feature. Thus, it was changed to "introspection". However, it was requested we make the name at least 11% sillier so there was no question that we honestly do not care what the final name will be, and to avoid what would undoubtedly be an entirely worthless bikeshed session. Enter: `introwospection`.

Introwospection's core ideals are as follows:

- does not force the user to pay for what they do not use (if a type is not reflected on, then no information about it whatsoever should show up in the final artifacts);
- will not produce run-time, dynamic allocations, nor will it require it under any circumstances (making it suitable for constrained and resource-starved environments);
- will produce information that can be acted upon by the type system or at compile-time (i.e. `const fn` time) without exception;
- can be utilized to inspect types and values within generic functions, including values and types of values not owned by the current crate;
- and, cannot be utilized to inspect private or hidden properties that are invisible to code at the current scope, module, or crate.

These core ideals shape what we want out of the API, and how it differs from existing attempts such as [David Tolnay's reflect](https://github.com/dtolnay/reflect) (a form of reflection relying purely on procedural macro programming and a better, more generalized form of reflected values) or [Bevy's `bevy_reflect`](https://docs.rs/bevy_reflect/0.10.1/bevy_reflect/) (a form of runtime reflection based on explicitly marked and cooperative registration of types and functions, limited to specific function shapes, specific (implemented) traits, and marked data types). Notably, introwospection wants to be able to work with *any* type whatsoever, rather than types that provide a specific implementation or types that you explicitly own. To explain some of this requires us to go back, and talk about the way things work today, including the fact that Rust does not have compile-time reflection like folks originally explained to us when we first started the language a couple of years ago.




# Wait, **Doesn't** Rust Have Reflection Already?

It is forgivable to hold this belief. We held this belief upon first seeing Rust a long time ago. Consider, briefly, this code from the [rocket.rs](https://rocket.rs/) front page project as of April 13th, 2023:

```rust
	#[macro_use] extern crate rocket;

	#[get("/hello/<name>/<age>")]
	fn hello(name: &str, age: u8) -> String {
		format!("Hello, {} year old named {}!", age, name)
	}

	#[launch]
	fn rocket() -> _ {
		rocket::build().mount("/", routes![hello])
	}
```

This code — apparently, with magic — is capable of understanding that you want an string (`&str`, in this case, which is a reference to an existing string object) to designate a name, and an 8-bit integer for the age. It parses that automatically from the `<name>` and `<age>` portions of this `get`-labeled route. It also returns a string, that will then be transported in a basic HTTP-valid form of transportation all the way to the user's browser. This means that — somehow — Rocket understands this `hello` function, its parameters, its return types, and — more importantly — the **negotiation** of these properties to and from a form understood by all web browsers. Is that not reflection? The ability to gaze into normal Rust code as written, and automatically generate the boilerplate and interop? Clearly, Rust had achieved something that C users only dream of, and that they can only produce with externally-orchestrated tools connected by `make` (or CMake, or meson, or Bazel, or any of the other dozens of build systems holding up a Mt. Everest of code).

Unfortunately, this is only half of the story.

What is happening here is not reflection, which dismayed us greatly as we learned the language. It is actually the machinations of a separate system that has been built on top of Rust's actual programming language. A separate shadow world whose job it is to do the immense heavy lifting that makes code like this possible. And that entire shadow world that's powering the most elegant Rust code starts with a single crate maintained and propelled forward by David Tolnay and his devout helpers, poetically named `syn`.



## `syn`

[The `syn` crate](https://docs.rs/syn/latest/syn/) (said like the first part of the word "syntax" and exactly like the word "sin") is the Big Mover and Shaker of Rust. When things get unwieldy to express and complicated to keep typing out in C, one falls back to the preprocessor system. Similarly, Rust programmers fall back to their own token expansion / generation  system, termed "macros". Exactly like the C counterpart, Rust's macro programming model does not actually understand anything about the program itself. It receives a stream of tokens, similar to the way invoking a function macro in C `DO_CALL(A, B, 234, str)` in C gets a list of tokens to interact with. Furthermore, normal Rust macros are further enhanced beyond C's preprocessor by the ability to effectively call and do whatever they want by acting as a compiler plugin for that token stream. These enhanced Rust macros are called procedural macros, and truly kick the floodgates of preprocessing wide open for Rust programs. While C object and function macros are extremely limited in scope and power — despite running on the same conceptual level as Rust macros — Rust macros are so fully-featured that one can reimplement the entire Rust Frontend in their Rust macro feature. Others new to Rust but well-aged in many programming languages — save for the older Lisp veterans — would scoff. If you suggested implementing a C frontend out of token parsing in C, you would be laughed out of the room for wanting a preprocessor that powerful. Well, not only is Rust's preprocessor theoretically that powerful on-paper, it is in-practice exactly that powerful as `syn` is the culmination of that very idea.

`syn` is a library that parses a stream of Rust tokens into Rust-understood and intimately recognizable constructs such as an `syn::Expression`, a `syn::Type`, `syn::AssocType`, `syn::DataUnion`, and so much more.

The special `#[launch]` and `#[get(...)]` macros from the Rocket example are how `syn` is deployed. Libraries use these attributes as the hooking points and jumping points for their macros and procedural macros. Then, they dip their hands into `syn` to parse and handle these Rust constructs in order to generate code. This, effectively, means that every macro and procedural macro is *re-doing* the work of the Rust frontend (up to its AST generation), and then acting on that in order to generate code for constructs (types, associated items, names, and traits) it recognizes. This is how Rocket knows to generate a `main` function for us with `#[launch]`, knows how to generate the boilerplate that connects a fully-received HTTP Request into something that can talk to our `hello` function, etc. etc.! It is an amazing feat of engineering. Make no mistake, David Tolnay plus the 80+ contributors to this crate are one of several critical pillars of why Rust is a major system's programming language worth taking seriously today. It bought a serious amount of time for the language designers and the numerous compiler engineers to focus on other parts of Rust, while use cases involving generating code and similar could be wrapped up in (proc) macros.

As with most engineering approaches born out of necessity, macros with Rust source code parsing in a preprocessing language has come with interesting consequences exacerbated by Rust's programming model. In particular, Rust's strong ownership rules (not just for resources, but for code concepts) means that macros very quickly hit very particular limits. Sometimes, those limits are billed as advantages, but with our work we have begun to see it as more of a hindrance than a drawback. We will take a slight detour to explain code ownership, specifically in relation to the C model, and expound upon how it relates to compile-time reflection.




## Strong Ownership: Not Just for Resources

One of the things that makes C and C++ a bit brutal on code is that, in conjunction with a source-text `#include`-based model of programming, ownership becomes very hard to define. Multiple translation units may end up with a function, structure, or similar with an identical namespace and name. How C and C++ handle this is effectively a shrug of the shoulders with a rule called the One Definition Rule. Effectively, it states that multiple translation units that do not opt into certain modifying keywords (e.g., `static`, anonymous top-level namespaces `namespace { … }`, or `extern`) promise that any code with identically-named entities shall have the same content, Or Else™. That "Or Else" is not always enforced, as its placed under either implicit undefined behavior (C) or as Ill-formed, No Diagnostic Required (IFNDR, C++). These days, *some* compilers can check these assumptions (e.g., GCC or Clang, with `-Wodr` AND Link-Time Optimizations/Link-Time Code Generation turned on). But for the most part, if the code from two or more translation units have identical names, compilers just play a quick game of Russian Roulette and eliminate all but one version of the code. It should not matter if there are multiple versions because we promised that all versions will be the same. This sometimes gets violated (because of different translation unit compilations using different macro definitions, or producing odd compile-time values that go into functions to provoke differing behavior), and it results in occasional hilarity as well as brutal, tear-filled 3 AM debugging sessions.

Rust sidesteps this problem entirely by basing their code concepts not within translation units that get blended into an executable later, but instead with conceptual modules and crates. We will not regale you with the details here, but effectively functions, structures, unions, traits, and more all belong to the modules and crates that define them. Code is included through the use of `use` importations and similar, and this allows strong ownership of code that belongs to one logical entity (the crate, and within a crate, to the module) rather than every single file (translation unit) claiming total control over every single piece of code that gets `#include`d in. This gets rid of quite a few obvious flaws from C, most notably the need to manically mark every header-implemented function with `inline` and then spend billions in compute cycles deduplicating the mess.

The drawbacks that start showing up, especially in relation to the macro system and generic programming systems in Rust, is about that strong ownership property.



### Traits and Ownership

Consider a trait in a given a crate `cats`, such as:

```rust
	pub trait Purr {
		fn do_purr(&self);
	}
```

In our own library (which is its own crate), we have a structure called `Lion`:

```rust
	pub struct Lion {}
```

We are allowed to implement the trait `Purr` for our `Lion` like so, in our own library:

```rust
	use cats::Purr;

	pub struct Lion {}

	impl Purr for Lion {
		fn do_purr (&self) {
			println!("purr")
		}
	}
```

This works fine for our own code in our own programs/libraries. However, consider a different structure named `Puma` that exists in another library `big_animals`. It doesn't have an implementation of `Purr` on it, but a `Puma` is a (big) cat, so we'd like to add one. So, in our own library again, we try to import the `Puma` structure and add the necessary `Purr` implementation:

```rust
	use big_animals::Puma;
	use cats::Purr;

	impl Purr for Puma {
		fn do_purr (&self) {
			println!("purr")
		}
	}
```

This does not compile. It runs afoul of what's called the Orphan Rule, which is part of a broader Rust property called coherence. The short definition of the Orphan Rule is as follows:

> You cannot provide implementations of a trait for a struct unless you are either the crate that defines the struct, or the crate that defines the trait.

Knowing this, `big_animals` cannot have someone outside of it add the `cats::Purr` trait on it, as that runs afoul of both coherence and, specifically, the Orphan Rule. This presents one of the biggest problems that Rocket, rlua, clap, and so many other codebases have to struggle with when they do `#[derive(...)]` based or Trait-based programming. There are many ways to get around such an issue, but almost every solution requires additional wrappers and special types. For example, for the problem with `Puma` above, there's 2 ways to go about this: create a new trait, or create a new type. The latter is the solution that is nominally used, wherein the "new type idiom" is used. It works, fundamentally, like this:

```rust
	use cats::Purr;

	struct MyPuma(big_animals::Puma);

	impl Purr for MyPuma {
		fn do_purr (&self) {
			println!("purr")
		}
	}
```

This is, ostensibly, not very workable if you have to pass a `Puma` into a function to do some work, or receive a `Puma` back. In either case, you need to "unpack" (easy enough by doing `my_puma_thing.0`) or you have to construct a `MyPuma` every time you get it back (e.g., `MyPuma(thing_that_makes_a_puma())`). Both of these are anathema to typical metaprogramming contexts, and it has been a problem for so long that automatic implementations using (procedural) macros based on custom derives/attributes (e.g.`#[derive(my_derive_attrib)]`) tend to pick up on "new type" definitions using `syn` and automatically try to unpack them using `.0` and passing to a base implementation. Occasionally, that does not pan out especially in the case of e.g. `MyPuma`. The object from `self.0` does not produce an object whose type implements `Purr`, so such automated handling is unhelpful for many cases of the new type idiom.

many crates need to add "features" onto themselves to accommodate other traits which are considered more base and important. For example, many crates include a `{crate-name}-serde` feature on it.


Despite having a deep similarity to interfaces of Java and C#, Traits 

Here, we explore a possible future for compile-time *introspection* (different from code-generating *reflection*) in the [Rust](https://rust-lang.org) Programming Language as part of the work for our Rust Foundation Grant., but spend the post laying out the work that would be required to reach the goals set out in this report.








--------------------------------




We will start with explaining the API and compiler interface itself, then dive into the reasons for design choices, how it avoids some of the pitfalls of alternatives, and the challenges we will have to face down in order to make it happen (as well as some shortcuts that can be done to get around the lack of many unstable, incomplete Rust features).


## `introwospection` at a Low Level

At its core, `introwospection` attempts to invert the `#[derive(MakeSomeTrait)]`-style of code generation and instead substitute it with true compile-time introspection, utilizing information the compiler already has. Here is a basic example of the API in a program crate called `cats_exec`:

```rust
	use std::introwospection::{FieldDescriptor, StructDescriptor};
	use std::mem::size_of;
	use std::any::type_name;

	pub struct Kitty {
		pub is_soft: bool,
		pub meows: i64,
		destruction_of_all_curtains_trigger: u32
	}

	fn main () {
		type KittyDesc = introwospect_type<Kitty>;
		println!("struct {}, with {} fields {{",
			<KittyDesc as StructDescriptor>::NAME,
			<KittyDesc as StructDescriptor>::FIELD_COUNT);
		println!("\t{} ({}, size {}, at {})",
			<KittyDesc::FieldsType as FieldDescriptor<0>>::NAME,
			std::any::type_name::<<KittyDesc::FieldsType as FieldDescriptor<0>>::Type>(),
			std::mem::size_of::<<KittyDesc::FieldsType as FieldDescriptor<0>>::Type>(),
			<KittyDesc::FieldsType as FieldDescriptor<0>>::BYTE_OFFSET);
		println!("\t{} ({}, size {}, at {})",
			<KittyDesc::FieldsType as FieldDescriptor<1>>::NAME,
			std::any::type_name::<<KittyDesc::FieldsType as FieldDescriptor<1>>::Type>(),
			std::mem::size_of::<<KittyDesc::FieldsType as FieldDescriptor<1>>::Type>(),
			<KittyDesc::FieldsType as FieldDescriptor<1>>::BYTE_OFFSET);
		println!("\t{} ({}, size {}, at {})",
			<KittyDesc::FieldsType as FieldDescriptor<2>>::NAME,
			std::any::type_name::<<KittyDesc::FieldsType as FieldDescriptor<2>>::Type>(),
			std::mem::size_of::<<KittyDesc::FieldsType as FieldDescriptor<2>>::Type>(),
			<KittyDesc::FieldsType as FieldDescriptor<2>>::BYTE_OFFSET);
		println!("}}")
	}
```

The integer constant `I` for `FieldDescriptor<I>` is the declaration (source code) index. We are accessing each field explicitly, one at a time. All of the information can be carried through `const fn`s and/or the type system: in this example, we use `introwospect_type<...>`, which takes a single type argument to display the  which will ultimately print:

```shell
	struct cats_exec::Kitty, with 3 fields {
		is_soft (bool, size 1, at 12)
		meows (i64, size 8, at 0)
		destruction_of_all_curtains_trigger (u32, size 4, at 8)
	}
```

Those not used to Rust will note that — when not annotated by a specific kind of `#[repr(...)]` attribute — byte offsets do not correspond to a linear sequence within the structure. They can be rearranged at will, which is why the API uses the `0`/`1`/.../up-to-`::FIELD_COUNT - 1` values that correspond to the unique declaration index rather than any other metric. Each `FieldDescriptor<I>` trait implementation yields the information about that field on the structure. This API also does not allow access to e.g. crate-hidden or private fields. For example, if `Kitty` is moved out of `cats_exec` and is instead in a crate named `felines`, the code will be unable to access Field 2. So, with `felines/src/Kitty.rs`:

```rust
	pub struct Kitty {
		pub is_soft: bool,
		pub meows: i64,
		destruction_of_all_curtains_trigger: u32
	}
```

And `cats_exec/src/main.rs`:

```rust
	use std::introwospection::{FieldDescriptor, StructDescriptor};
	use std::mem::size_of;
	use std::any::type_name;
	use felines::Kitty;

	fn main () {
		type KittyDesc = introwospect_type<Kitty>;
		println!("struct {}, with {} fields {{",
			<KittyDesc as StructDescriptor>::NAME,
			<KittyDesc as StructDescriptor>::FIELD_COUNT);
		println!("\t{} ({}, size {}, at {})",
			<KittyDesc::FieldsType as FieldDescriptor<0>>::NAME,
			std::any::type_name::<<KittyDesc::FieldsType as FieldDescriptor<0>>::Type>(),
			std::mem::size_of::<<KittyDesc::FieldsType as FieldDescriptor<0>>::Type>(),
			<KittyDesc::FieldsType as FieldDescriptor<0>>::BYTE_OFFSET);
		println!("\t{} ({}, size {}, at {})",
			<KittyDesc::FieldsType as FieldDescriptor<1>>::NAME,
			std::any::type_name::<<KittyDesc::FieldsType as FieldDescriptor<1>>::Type>(),
			std::mem::size_of::<<KittyDesc::FieldsType as FieldDescriptor<1>>::Type>(),
			<KittyDesc::FieldsType as FieldDescriptor<1>>::BYTE_OFFSET);
		// Compile-time error
		// <KittyDesc::FieldsType as FieldDescriptor<2>>
		// would error!
		/*
		println!("\t{} ({}, size {}, at {})",
			<KittyDesc::FieldsType as FieldDescriptor<2>>::NAME,
			std::any::type_name::<<KittyDesc::FieldsType as FieldDescriptor<2>>::Type>(),
			std::mem::size_of::<<KittyDesc::FieldsType as FieldDescriptor<2>>::Type>(),
			<KittyDesc::FieldsType as FieldDescriptor<2>>::BYTE_OFFSET);
		*/
		println!("}}")
	}
```

Which would produce:

```shell
	struct felines::Kitty, with 2 fields {
		is_soft (bool, size 1, at 12)
		meows (i64, size 8, at 0)
	}
```

This means we have a privacy-respecting way of looking at the data for a type which is not part of a crate we authored! There is just one small problem with the above code, unfortunately.



## It. Is. U G L Y.

It does not take an opinionated code beautician or a grizzled Staff Engineer to look at the above code and tell you that this has to be the world's ugliest API in existence. Nobody wants to write the above, nobody wants to hard-code source-level indices, nobody wants to constantly cast some type to a given field descriptor (and Rust does not allow you to have a local `type trait KittyTrait = KittyDesc as FieldDescriptor<0>;` or something, to at least make the above less awful). It's a terrible way to program. Which, thankfully, is fine, because there is an infinitely better way to work with these things through the `std::introwospection`-provided "visitor" types. To make things easier, we just have to implement a basic visitor type:

```rust
	use std::introwospection::{FieldDescriptor, StructDescriptor, };
	use std::mem::size_of;
	use std::any::type_name;
	use felines::Kitty;

	struct DescriptorPrinter;

	impl FieldDescriptorVisitor for DescriptorPrinter {
		
		type Output = ()
		
		fn visit_field<Type, const INDEX: usize>(&self)
		-> Self::Output
		where Type : FieldDescriptor<INDEX>
		{
			let type_name = std::any::type_name::<Type::Type>();
			let member_size = std::mem::size_of::<Type::Type>();
			println!("\t{} ({}, size {}, at {})",
				Type::NAME,
				type_name,
				member_size,
				Type::BYTE_OFFSET);
		}
	}

	impl StructDescriptorVisitor for DescriptorPrinter {
		
		type Output = ()

		fn visit_struct<Type>(&self)
		-> Self::Output
		where Type : StructDescriptor
		{
			println!("struct {}, with {} fields {{",
				Type::NAME,
				Type::FIELD_COUNT);
			// now, introspect over the fields of this type.
			( introwospect_over(Type::Type, Type::FieldsType, self) );
			println!("}}");
		}
	}

	fn main () {
		let visitor = DescriptionPrinter;
		introwospect(Kitty, visitor);
	}
```

Which would produce output identical to the one above:

```shell
	struct felines::Kitty, with 2 fields {
		is_soft (bool, size 1, at 12)
		meows (i64, size 8, at 0)
	}
```

Visitors are intended to be the mid-level API. They offer a large amount of flexibility, and in conjunction with the `introwospect` keyword allow for easily iterating through the public, visible fields on `struct`s, `union`s, `enum`s `fn`s, and other types. This level of compile-time introspection allows us to perform algorithms based on the visible objects of a type.



--------------





But, to understand this, we need to have a quick crash course on the kind of techniques Rust is currently employing to get their work done, today.





*Disclosure: This work was made possible by a Grant from the Rust Foundation. For more information, please visit the [Rust Foundation Grants page](https://foundation.rust-lang.org/grants/).*

{{< anchors >}}
